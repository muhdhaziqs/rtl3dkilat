<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>RTL-3D — Real-Time Monitoring System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="RTL-3D KILAT" />
  <meta name="keywords" content="Real-Time Lightning 3D Imaging and Forecasting Project" />
  <meta name="author" content="rtlsatreps.utem.edu.my" />
  <meta http-equiv="refresh" content="600" />

  <!-- CesiumJS -->
  <link href="https://unpkg.com/cesium/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <script src="https://unpkg.com/cesium/Build/Cesium/Cesium.js"></script>

  <!-- PapaParse (CSV) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Your existing styles/libs (optional) -->
  <link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700" rel="stylesheet">
  <link rel="stylesheet" href="css/animate.css">
  <link rel="stylesheet" href="css/icomoon.css">
  <link rel="stylesheet" href="css/bootstrap.css">
  <link rel="stylesheet" href="css/flexslider.css">
  <link rel="stylesheet" href="css/style.css">
  <script src="js/modernizr-2.6.2.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; }
    #topbar { display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:center; margin:16px 0 8px; }
    #viewerWrap { width:95%; height:78vh; margin:10px auto; position:relative; border:2px solid #ccc; box-shadow:0 0 10px rgba(0,0,0,0.2); }
    #viewer { width:100%; height:100%; }
    .badge { display:inline-block; padding:2px 6px; border-radius:4px; background:#eee; margin-left:6px; font-size:12px;}
    .hint { text-align:center; color:#666; margin-top:6px; }
    .btn { cursor:pointer; }

    .origin-box { display:flex; gap:12px; align-items:center; }
    .origin-box label { margin-right:4px; }

    /* Compact animation control overlay (bottom-left) */
    #animBar {
      position: absolute;
      left: 10px;
      bottom: 10px;
      z-index: 15;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(0, 0, 0, 0.25);
      border-radius: 6px;
      padding: 4px 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
      justify-content: flex-start;
      font-size: 11px;
      line-height: 1.2;
      backdrop-filter: blur(3px);
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
      max-width: 320px;
    }
    #animBar .group { display: flex; align-items: center; gap: 4px; }
    #animBar button {
      border: 1px solid #aaa;
      background: #f7f7f7;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 11px;
      line-height: 1.1;
      cursor: pointer;
    }
    #animBar button.active { border-color: #333; }
    #animBar input[type="range"] { width: 120px; height: 4px; }
    #timeLabel { min-width: 90px; text-align: center; font-family: monospace; font-size: 10px; }
    @media (max-width: 768px) {
      #animBar { left: 6px; bottom: 6px; font-size: 10px; padding: 3px 5px; max-width: 280px; }
      #animBar input[type="range"] { width: 100px; }
    }

    /* Legend overlay on the map (top-left) */
    #legendOverlay {
      position:absolute; left:10px; top:10px; z-index:10;
      background:rgba(255,255,255,0.85);
      border:1px solid rgba(0,0,0,0.2);
      border-radius:8px;
      padding:8px 10px;
      font-size:12px;
      backdrop-filter: blur(2px);
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      max-width: 240px;
    }
    #legendOverlay h4 { margin:0 0 6px; font-size:13px; font-weight:700; }
    .legend-row { display:flex; align-items:center; gap:8px; margin:2px 0; }
    .legend-dot { width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid #00000022; }
    .legend-note { margin-top:6px; color:#333; font-size:11px; }
  </style>
</head>

<body>
<div id="page">
  <nav class="fh5co-nav" role="navigation">
    <div class="top-menu">
      <div class="container">
        <div class="row">
          <div class="col-xs-2">
            <div id="fh5co-logo"><a href="index.html">RTL-3D<span>.</span></a></div>
          </div>
          <div class="col-xs-10 text-right menu-1">
            <ul>
              <li><a href="index.html">Home</a></li>
              <li><a href="realtime.html">Real-time</a></li>
              <li class="active"><a href="realtime_3d.html">Charge Distribution</a></li>
              <li class="has-dropdown">
                <a href="#">Monitor</a>
                <ul class="dropdown">
                  <li><a href="monitor-trigger.html">Daily Trigger Statistics</a></li>
                  <li><a href="monitor-site-signal.html">Site-Recorded Waveform Output</a></li>
                  <li><a href="monitor-site-status.html">Site status</a></li>
                </ul>
              </li>
              <li class="btn-cta"><a href="#"><span>Login</span></a></li>
            </ul>
          </div>
        </div>      
      </div>
    </div>
  </nav>

  <h2 style="text-align:center;">Lightning 3D Charge Distribution</h2>
  <h4 style="text-align:center;">Current time <span id="datetime"></span></h4>
  <h5>
  <div id="topbar">
    <div>
      <label for="serverFile">Select data (server):</label>
      <select id="serverFile" disabled>
        <option>Loading file list…</option>
      </select>
      <button id="loadServerBtn" class="btn" disabled>Load</button>
    </div>
    <div>
      <label for="localFile">or Upload CSV:</label>
      <input type="file" id="localFile" accept=".csv" />
    </div>

    <div>
      <label for="sizeScale">Point size:</label>
      <input type="range" id="sizeScale" min="1" max="12" value="5" />
    </div>
    <div>
      <span class="badge" id="activeFileBadge">No file loaded</span>
    </div>
  </div>
  </h5>

  <!-- Map + overlays -->
  <div id="viewerWrap">
    <!-- Legend overlay (top-left) -->
    <div id="legendOverlay">
      <h4>Legend</h4>
      <div class="legend-row"><span class="legend-dot" style="background:black;"></span> Sensor</div>
      <div class="legend-row"><span class="legend-dot" style="background:red;"></span> Negative charge</div>
      <div class="legend-row"><span class="legend-dot" style="background:blue;"></span> Positive charge</div>
      <div class="legend-row"><span class="legend-dot" style="background:#999;"></span> Zero</div>
      <div class="legend-note">✕ = initiation point</div>
    </div>

    <!-- Cesium viewer -->
    <div id="viewer"></div>

    <!-- Animation UI overlay (bottom-left) -->
    <div id="animBar">
      <div class="group">
        <button id="playPauseBtn">⏸ Pause</button>
        <button id="resetBtn">⟲ Reset</button>
        <button id="showAllBtn">Show All</button>
      </div>
      <div class="group">
        <strong>Speed:</strong>
        <button class="spd active" data-s="0.1">×0.1</button>
        <button class="spd" data-s="0.25">×0.25</button>
        <button class="spd" data-s="0.5">×0.5</button>
        <button class="spd" data-s="1">×1</button>
        <button class="spd" data-s="2">×2</button>
      </div>
      <div class="group">
        <input id="progress" type="range" min="0" max="1000" step="1" value="0" />
        <span id="timeLabel">—</span>
      </div>
    </div>
  </div>

  <div class="hint">Tip: hold <b>right mouse</b> to tilt, <b>left</b> to pan, <b>wheel</b> to zoom. Click a point for time/charge.</div>

  <footer id="fh5co-footer" role="contentinfo">
    <div class="container">
      <div class="row copyright">
        <div class="col-md-12 text-center">
          <p>
            <small class="block">&copy;2025 <a href="https://rtlsatreps.utem.edu.my/" target="_blank"> RTL-3D KILAT</a>. All Rights Reserved.</small>
            <small class="block">Designed by <a href="http://electrazcorp.com/?i=1" target="_blank">muhdhaziq.s</a></small>
          </p>
          <p>
            <ul class="fh5co-social-icons">
              <li><a href="https://www.instagram.com/satreps_rtl3d/"><i class="icon-instagram"></i></a></li>
              <li><a href="https://www.facebook.com/rtl3d"><i class="icon-facebook"></i></a></li>
            </ul>
          </p>
        </div>
      </div>
    </div>
  </footer>
</div>

<!-- (Optional) your existing JS libs -->
<script src="js/jquery.min.js"></script>
<script src="js/jquery.easing.1.3.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/jquery.waypoints.min.js"></script>
<script src="js/jquery.flexslider-min.js"></script>
<script src="js/main.js"></script>

<script>
(async () => {
  // ---------------- Clock ----------------
  function updateDateTime() {
    const options = { weekday:'long', year:'numeric', month:'long', day:'numeric',
                      hour:'2-digit', minute:'2-digit', second:'2-digit' };
    document.getElementById('datetime').textContent = new Date().toLocaleString(undefined, options);
  }
  updateDateTime(); setInterval(updateDateTime, 1000);

  // ---------------- Config ----------------
  const CESIUM_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzMTIxNTA4ZC0zMmMyLTQwNGMtOTUwOS05ZGM4MGYxM2NmYWQiLCJpZCI6MzQ4NTY0LCJpYXQiOjE3NTk5ODI1Nzh9.a-OxpSR-L9mz3OHMK5ZGTvZW3bmH0S6Yybmybjq3yek';
  if (CESIUM_TOKEN) Cesium.Ion.defaultAccessToken = CESIUM_TOKEN;

  const ENABLE_OSM_BUILDINGS = true;

  // Origins for ENU projection of event data
  const ORIGINS = {
    utem: { name: "UTeM", lat: 2.313906, lon: 102.318485 },
    uitm: { name: "UiTM Jasin", lat: 2.228031, lon: 102.458427 }
  };
  ORIGINS.mid = {
    name: "Midpoint",
    lat: (ORIGINS.utem.lat + ORIGINS.uitm.lat) / 2,
    lon: (ORIGINS.utem.lon + ORIGINS.uitm.lon) / 2
  };
  function selectedOrigin() {
    return ORIGINS.utem; // keep UTeM as ENU origin for event reprojection
  }

  // ✅ Full station list (with lon/lat/elevation)
  const STATIONS = [
    { name: 'MKPL',        lon: 102.249010,  lat: 2.726931,  elev_m: 129 },
    { name: 'UTNL',        lon: 101.728753,  lat: 2.9693250, elev_m: 68 },
    { name: 'DAML',        lon: 101.6844350, lat: 3.2759890, elev_m: 104 },
    { name: 'PJWL',        lon: 101.4913470, lat: 3.0457980, elev_m: 9 },
    { name: 'PBSL',        lon: 102.3341120, lat: 2.1133980, elev_m: 14.5 },
    { name: 'KUTL',        lon: 101.9647200, lat: 2.4042190, elev_m: 10 },
    { name: 'FLKL',        lon: 102.0833910, lat: 2.2938660, elev_m: 28 },
    { name: 'UTeM',        lon: 102.3184420, lat: 2.3139620, elev_m: 90 },
    { name: 'UiTM Jasin',  lon: 102.4582250, lat: 2.2280433, elev_m: 29 }
  ];

  // ENU (east, north, up) in km -> geodetic
  function enuKmToGeodetic(x_km, y_km, lat0_deg, lon0_deg) {
    const lat0 = lat0_deg * Math.PI/180;
    const mPerDegLat = 111132.92 - 559.82*Math.cos(2*lat0) + 1.175*Math.cos(4*lat0);
    const mPerDegLon = (Math.PI/180) * 6378137 * Math.cos(lat0);
    const dLatDeg = (y_km * 1000) / mPerDegLat;
    const dLonDeg = (x_km * 1000) / mPerDegLon;
    return { lat: lat0_deg + dLatDeg, lon: lon0_deg + dLonDeg };
  }

  // parse time (epoch s/ms or ISO) -> ms
  function toMs(t) {
    if (t == null) return NaN;
    if (typeof t === 'number') {
      if (t > 1e12) return t;          // ms
      if (t > 1e9)  return t * 1000;   // seconds
      return t * 1000;
    }
    const n = Number(t);
    if (!isNaN(n)) return toMs(n);
    const d = new Date(t);
    return isNaN(d) ? NaN : d.getTime();
  }

  // ---------------- Viewer ----------------
  async function makeViewer() {
    const hasToken = !!CESIUM_TOKEN;

    const imageryProvider = hasToken
      ? await Cesium.IonImageryProvider.fromAssetId(2)
      : new Cesium.UrlTemplateImageryProvider({
          url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
          credit: '© OpenStreetMap contributors'
        });

    const terrainProvider = hasToken
      ? await Cesium.CesiumTerrainProvider.fromIonAssetId(1, {
          requestVertexNormals: true,
          requestWaterMask: true
        })
      : new Cesium.EllipsoidTerrainProvider();

    const v = new Cesium.Viewer('viewer', {
      imageryProvider,
      terrainProvider,
      baseLayerPicker: false,
      geocoder: false,
      animation: false,
      timeline: false,
      homeButton: true,
      sceneModePicker: true,
      navigationHelpButton: false,
      selectionIndicator: true
    });

    v.scene.globe.enableLighting = hasToken;
    v.scene.globe.depthTestAgainstTerrain = true;

    // Subtle terrain styling
    const LIGHT_BROWN = '#bca974';
    v.scene.globe.baseColor = Cesium.Color.fromCssColorString(LIGHT_BROWN);
    v.scene.globe.material = Cesium.Material.fromType('Color', {
      color: Cesium.Color.fromCssColorString(LIGHT_BROWN).withAlpha(0.85)
    });
    v.scene.globe.maximumScreenSpaceError = 1.5;
    v.scene.globe.terrainExaggeration = 1.25;

    if (hasToken && ENABLE_OSM_BUILDINGS) {
      try {
        const osmBuildings = await Cesium.createOsmBuildingsAsync();
        v.scene.primitives.add(osmBuildings);
      } catch (err) { console.warn('OSM Buildings unavailable:', err); }
    }

    // Frame initial view to include all stations
    const rect = stationsRectangle();
    v.camera.flyTo({
      destination: rect ?? Cesium.Rectangle.fromDegrees(99.5, 1.0, 104.8, 7.0),
      duration: 0
    });

    return v;
  }

  // Compute bounding rectangle for stations
  function stationsRectangle() {
    if (!STATIONS.length) return null;
    let minLat=+Infinity, minLon=+Infinity, maxLat=-Infinity, maxLon=-Infinity;
    STATIONS.forEach(s => {
      minLat = Math.min(minLat, s.lat);
      minLon = Math.min(minLon, s.lon);
      maxLat = Math.max(maxLat, s.lat);
      maxLon = Math.max(maxLon, s.lon);
    });
    const pad = 0.15;
    return Cesium.Rectangle.fromDegrees(minLon - pad, minLat - pad, maxLon + pad, maxLat + pad);
  }

  const viewer = await makeViewer();

  // ---------------- Station pins (raised above terrain) ----------------
  STATIONS.forEach(s => {
    // Elevation above ground + small extra so it floats visibly
    const altAGL = (Number(s.elev_m) || 0) + 5;

    // Station marker + label
    viewer.entities.add({
      name: s.name,
      position: Cesium.Cartesian3.fromDegrees(s.lon, s.lat, altAGL),
      point: {
        pixelSize: 10,
        color: Cesium.Color.BLACK,
        outlineColor: Cesium.Color.WHITE,
        outlineWidth: 2,
        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      },
      label: {
        text: `${s.name} (${s.elev_m} m)`,
        font: '14px sans-serif',
        fillColor: Cesium.Color.BLACK,
        showBackground: true,
        backgroundColor: Cesium.Color.fromAlpha(Cesium.Color.WHITE, 0.85),
        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
        pixelOffset: new Cesium.Cartesian2(0, -16),
        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
        disableDepthTestDistance: Number.POSITIVE_INFINITY
      },
      description: `
        <b>${s.name}</b><br/>
        Lon, Lat: ${s.lon.toFixed(6)}, ${s.lat.toFixed(6)}<br/>
        Elevation: ${s.elev_m} m (AGL)
      `
    });

    // “Mast” from terrain to marker for clarity
    viewer.entities.add({
      polyline: {
        positions: Cesium.Cartesian3.fromDegreesArrayHeights([
          s.lon, s.lat, 0,
          s.lon, s.lat, altAGL
        ]),
        width: 2,
        material: Cesium.Color.BLACK.withAlpha(0.6),
        clampToGround: false
      }
    });
  });

  // ---------------- UI refs ----------------
  const serverFileSel = document.getElementById('serverFile');
  const serverLoadBtn = document.getElementById('loadServerBtn');
  const localFileInput = document.getElementById('localFile');
  const badge = document.getElementById('activeFileBadge');
  const sizeScaleInput = document.getElementById('sizeScale');

  // Animation refs
  const playPauseBtn = document.getElementById('playPauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const showAllBtn = document.getElementById('showAllBtn');
  const progress = document.getElementById('progress');
  const timeLabel = document.getElementById('timeLabel');
  const speedBtns = Array.from(document.querySelectorAll('.spd'));

  // ---------------- Point primitives ----------------
  let negPoints=null, posPoints=null, zeroPoints=null;
  function clearPoints() {
    if (negPoints) viewer.scene.primitives.remove(negPoints);
    if (posPoints) viewer.scene.primitives.remove(posPoints);
    if (zeroPoints) viewer.scene.primitives.remove(zeroPoints);
    negPoints=posPoints=zeroPoints=null;
  }
  function makeCollection(color) {
    const col = new Cesium.PointPrimitiveCollection();
    col._rtl3d_color = color; return col;
  }
  sizeScaleInput.addEventListener('input', () => {
    const px = Number(sizeScaleInput.value);
    [negPoints,posPoints,zeroPoints].forEach(col => {
      if (!col) return; for (let i=0;i<col.length;i++) col.get(i).pixelSize = px;
    });
  });

  function detectGeodetic(rows) {
    if (!rows.length) return false;
    const r = rows.find(rr => rr && (('lon' in rr) || ('longitude' in rr)) && (('lat' in rr) || ('latitude' in rr)));
    return !!r;
  }

  // ---------------- Animation Engine ----------------
  const anim = {
    rowsSorted: [],
    startMs: NaN,
    endMs: NaN,
    simMs: 0,
    idx: 0,
    playing: false,
    speed: 0.1,
    lastFrameTs: 0,
    firstMarker: null,
    boundsRect: null,
    loop: true
  };

  function setSpeed(s) {
    anim.speed = s;
    speedBtns.forEach(b => b.classList.toggle('active', Number(b.dataset.s)===s));
  }
  speedBtns.forEach(b => b.addEventListener('click', () => setSpeed(Number(b.dataset.s)) ));

  function updateTimeLabel(currentAbsMs) {
    if (!isFinite(anim.startMs) || !isFinite(anim.endMs)) { timeLabel.textContent = '—'; return; }
    const cur = Math.max(anim.startMs, Math.min(currentAbsMs, anim.endMs));
    const spanSec = (anim.endMs - anim.startMs)/1000;
    const tSec = (cur - anim.startMs)/1000;
    timeLabel.textContent = new Date(cur).toISOString() + `  (${tSec.toFixed(2)}s / ${spanSec.toFixed(2)}s)`;
  }

  function setProgressFromMs(currentAbsMs) {
    const frac = (currentAbsMs - anim.startMs) / (anim.endMs - anim.startMs);
    progress.value = Math.round(1000 * Math.max(0, Math.min(1, frac)));
    updateTimeLabel(currentAbsMs);
  }

  function addPoint(p) {
    const px = Number(sizeScaleInput.value);
    const pos = Cesium.Cartesian3.fromDegrees(p.lon, p.lat, p.alt_m);
    const tgt = p.charge < 0 ? negPoints : (p.charge > 0 ? posPoints : zeroPoints);
    const pt = tgt.add({ position: pos, color: tgt._rtl3d_color, pixelSize: px, disableDepthTestDistance: Number.POSITIVE_INFINITY });
    const text = `time: ${new Date(p.timeMs).toISOString()}\ncharge: ${p.charge}\nlon,lat,alt(m): ${p.lon.toFixed(6)}, ${p.lat.toFixed(6)}, ${Math.round(p.alt_m)}`;
    pt._rtl3d_info = { text };
  }

  function resetAnimationVisuals() {
    clearPoints();
    negPoints = makeCollection(Cesium.Color.RED);
    posPoints = makeCollection(Cesium.Color.BLUE);
    zeroPoints = makeCollection(Cesium.Color.GRAY);
    viewer.scene.primitives.add(negPoints);
    viewer.scene.primitives.add(posPoints);
    viewer.scene.primitives.add(zeroPoints);

    if (anim.firstMarker) { viewer.entities.remove(anim.firstMarker); anim.firstMarker = null; }

    if (anim.rowsSorted.length) {
      const fp = anim.rowsSorted[0];
      anim.firstMarker = viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(fp.lon, fp.lat, fp.alt_m),
        label: {
          text: '✕',
          font: 'bold 24px sans-serif',
          fillColor: Cesium.Color.RED,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 2,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          pixelOffset: new Cesium.Cartesian2(0, -12)
        },
        description: `Initiation point<br>${new Date(fp.timeMs).toISOString()}`
      });
    }
  }

  function prepareAnimation(rows, titleText) {
    const isGeodetic = detectGeodetic(rows);
    const origin = selectedOrigin();

    const pts = [];
    let minLat=+Infinity, minLon=+Infinity, maxLat=-Infinity, maxLon=-Infinity;

    for (const r of rows) {
      if (!r) continue;
      const charge = Number(r.deposited_charge);
      if (!isFinite(charge)) continue;

      const timeMs = toMs(r.time);
      if (!isFinite(timeMs)) continue;

      let lon, lat, alt_m;
      if (isGeodetic) {
        lon = Number(r.lon ?? r.longitude);
        lat = Number(r.lat ?? r.latitude);
        const zVal = Number(r.z); alt_m = Math.abs(zVal) > 200 ? zVal : zVal*1000;
      } else {
        const x_km = Number(r.x), y_km = Number(r.y), z_km = Number(r.z);
        if (!isFinite(x_km) || !isFinite(y_km) || !isFinite(z_km)) continue;
        const geo = enuKmToGeodetic(x_km, y_km, origin.lat, origin.lon);
        lon = geo.lon; lat = geo.lat; alt_m = z_km*1000;
      }
      if (!isFinite(lon) || !isFinite(lat) || !isFinite(alt_m)) continue;

      pts.push({ timeMs, lon, lat, alt_m, charge });

      minLat = Math.min(minLat, lat); minLon = Math.min(minLon, lon);
      maxLat = Math.max(maxLat, lat); maxLon = Math.max(maxLon, lon);
    }

    pts.sort((a,b) => a.timeMs - b.timeMs);
    anim.rowsSorted = pts;
    anim.startMs = pts.length ? pts[0].timeMs : NaN;
    anim.endMs   = pts.length ? pts[pts.length-1].timeMs : NaN;
    anim.simMs   = 0;
    anim.idx     = 0;
    anim.playing = false;
    anim.lastFrameTs = 0;

    if (pts.length) {
      anim.boundsRect = Cesium.Rectangle.fromDegrees(minLon, minLat, maxLon, maxLat);
      viewer.camera.flyTo({ destination: anim.boundsRect, duration: 1.2 });
    }

    resetAnimationVisuals();
    badge.textContent = 'Loaded: ' + titleText;
    setProgressFromMs(anim.startMs);

    setSpeed(0.1);
    anim.playing = true;
    playPauseBtn.textContent = '⏸ Pause';
    anim.lastFrameTs = 0;
    requestAnimationFrame(step);
  }

  function step(ts) {
    if (!anim.playing || !anim.rowsSorted.length) return;
    if (!anim.lastFrameTs) anim.lastFrameTs = ts;
    const dtRaw = ts - anim.lastFrameTs;
    const dt = Math.min(dtRaw, 150);
    anim.lastFrameTs = ts;

    anim.simMs += dt * anim.speed;
    let currentAbsMs = anim.startMs + anim.simMs;

    while (anim.idx < anim.rowsSorted.length && anim.rowsSorted[anim.idx].timeMs <= currentAbsMs) {
      addPoint(anim.rowsSorted[anim.idx]);
      anim.idx++;
    }

    setProgressFromMs(currentAbsMs);

    if (currentAbsMs >= anim.endMs) {
      if (anim.loop) {
        anim.simMs = 0;
        anim.idx = 0;
        resetAnimationVisuals();
        setProgressFromMs(anim.startMs);
        requestAnimationFrame(step);
      } else {
        anim.playing = false;
        playPauseBtn.textContent = '▶ Replay';
        setProgressFromMs(anim.endMs);
      }
      return;
    }
    requestAnimationFrame(step);
  }

  function playPause() {
    if (!anim.rowsSorted.length) return;
    anim.playing = !anim.playing;
    playPauseBtn.textContent = anim.playing ? '⏸ Pause' : '▶ Play';
    if (anim.playing) {
      anim.lastFrameTs = 0;
      requestAnimationFrame(step);
    }
  }

  function resetAnimation() {
    if (!anim.rowsSorted.length) return;
    anim.playing = false;
    playPauseBtn.textContent = '▶ Play';
    anim.simMs = 0;
    anim.idx = 0;
    resetAnimationVisuals();
    setProgressFromMs(anim.startMs);
  }

  function showAll() {
    if (!anim.rowsSorted.length) return;
    resetAnimationVisuals();
    for (const p of anim.rowsSorted) addPoint(p);
    anim.idx = anim.rowsSorted.length;
    anim.simMs = (anim.endMs - anim.startMs);
    setProgressFromMs(anim.endMs);
    anim.playing = false;
    playPauseBtn.textContent = '▶ Replay';
  }

  // UI wiring
  playPauseBtn.addEventListener('click', playPause);
  resetBtn.addEventListener('click', resetAnimation);
  showAllBtn.addEventListener('click', showAll);

  // scrubber
  let scrubbing = false;
  progress.addEventListener('input', () => {
    if (!anim.rowsSorted.length) return;
    scrubbing = true;
    const frac = Number(progress.value) / 1000;
    const targetAbsMs = anim.startMs + frac*(anim.endMs - anim.startMs);

    clearPoints();
    negPoints = makeCollection(Cesium.Color.RED);
    posPoints = makeCollection(Cesium.Color.BLUE);
    zeroPoints = makeCollection(Cesium.Color.GRAY);
    viewer.scene.primitives.add(negPoints);
    viewer.scene.primitives.add(posPoints);
    viewer.scene.primitives.add(zeroPoints);
    if (anim.firstMarker == null && anim.rowsSorted.length) {
      const fp = anim.rowsSorted[0];
      anim.firstMarker = viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(fp.lon, fp.lat, fp.alt_m),
        label: { text: '✕', font: 'bold 24px sans-serif',
                 fillColor: Cesium.Color.RED, outlineColor: Cesium.Color.BLACK, outlineWidth: 2,
                 style: Cesium.LabelStyle.FILL_AND_OUTLINE, pixelOffset: new Cesium.Cartesian2(0, -12) }
      });
    }
    let i=0;
    while (i < anim.rowsSorted.length && anim.rowsSorted[i].timeMs <= targetAbsMs) {
      addPoint(anim.rowsSorted[i]); i++;
    }
    anim.idx = i;
    anim.simMs = targetAbsMs - anim.startMs;
    updateTimeLabel(targetAbsMs);
  });
  progress.addEventListener('change', () => { scrubbing = false; });

  // ---------------- Click info ----------------
  const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
  handler.setInputAction(function (movement) {
    const picked = viewer.scene.pick(movement.position);
    if (Cesium.defined(picked) && picked.primitive && picked.primitive._rtl3d_info) {
      const info = picked.primitive._rtl3d_info.text;
      viewer.selectedEntity = new Cesium.Entity({ name: 'Point info', description: info.replace(/\n/g, '<br>') });
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

  // ---------------- CSV parsing & loading ----------------
  function parseCSV(text) {
    return new Promise((resolve, reject) => {
      Papa.parse(text, {
        header: true, dynamicTyping: true, skipEmptyLines: true,
        complete: res => resolve(res.data || []),
        error: err => reject(err)
      });
    });
  }

  async function tryLoadFileList() {
    try {
      const res = await fetch('./3D_txt/filelist.json', { cache: 'no-cache' });
      if (!res.ok) throw 0;
      const list = await res.json();

      serverFileSel.innerHTML = '';
      for (const fn of list) {
        const opt = document.createElement('option');
        opt.value = fn; opt.textContent = fn;
        serverFileSel.appendChild(opt);
      }

      serverFileSel.disabled = false;
      serverLoadBtn.disabled = false;

      if (list.length) {
        serverFileSel.selectedIndex = 0;
        await loadServerSelected();
      }
    } catch (e) {
      serverFileSel.innerHTML = '<option>No server file list (use Upload CSV)</option>';
      serverFileSel.disabled = true; serverLoadBtn.disabled = true;
    }
  }

  async function loadServerSelected() {
    const fname = serverFileSel.value; if (!fname) return;
    const url = './3D_txt/' + fname;
    const res = await fetch(url, { cache:'no-cache' });
    if (!res.ok) { alert('Failed to load: ' + fname); return; }
    const text = await res.text();
    const rows = await parseCSV(text);
    window._lastRows = rows; window._lastTitle = fname;
    prepareAnimation(rows, fname);
  }
  serverLoadBtn.addEventListener('click', loadServerSelected);

  localFileInput.addEventListener('change', async (ev) => {
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;
    const text = await file.text();
    const rows = await parseCSV(text);
    window._lastRows = rows; window._lastTitle = file.name;
    prepareAnimation(rows, file.name);
  });

  // Reproject on origin change (without reloading)
  document.querySelectorAll('input[name="origin"]').forEach(r => {
    r.addEventListener('change', () => {
      if (window._lastRows) prepareAnimation(window._lastRows, window._lastTitle || 'data');
    });
  });

  // Init: load list (auto-load first inside)
  await tryLoadFileList();

  // default speed button state (×0.1 already active in markup)
  setSpeed(0.1);
})();
</script>
</body>
</html>
